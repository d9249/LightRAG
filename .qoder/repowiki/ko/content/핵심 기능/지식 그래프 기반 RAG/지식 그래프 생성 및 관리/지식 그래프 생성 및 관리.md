
# 지식 그래프 생성 및 관리

<cite>
**이 문서에서 참조된 파일**   
- [lightrag.py](file://lightrag/lightrag.py)
- [operate.py](file://lightrag/operate.py)
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py)
- [shared_storage.py](file://lightrag/kg/shared_storage.py)
- [base.py](file://lightrag/base.py)
</cite>

## 목차
1. [소개](#소개)
2. [LightRAG 클래스의 저장소 초기화](#lightrag-클래스의-저장소-초기화)
3. [_rebuild_knowledge_from_chunks 함수 분석](#_rebuild_knowledge_from_chunks-함수-분석)
4. [동시성 제어 메커니즘](#동시성-제어-메커니즘)
5. [다양한 그래프 저장소 구현과의 호환성](#다양한-그래프-저장소-구현과의-호환성)
6. [트랜잭션 처리 및 데이터 무결성](#트랜잭션-처리-및-데이터-무결성)
7. [결론](#결론)

## 소개
이 문서는 LightRAG 프레임워크 내에서 지식 그래프의 생성 및 관리 프로세스를 심층적으로 분석합니다. 특히, `LightRAG` 클래스가 `chunk_entity_relation_graph`, `entities_vdb`, `relationships_vdb` 등의 다양한 저장소 인스턴스를 어떻게 초기화하고 관리하는지에 대해 설명합니다. 또한, `_rebuild_knowledge_from_chunks` 함수가 캐시된 추출 결과를 사용하여 지식 그래프를 재구성하는 방식과 `get_storage_keyed_lock`을 통한 동시성 제어 메커니즘을 분석합니다. 마지막으로, NetworkXStorage 외의 다른 그래프 저장소 구현(neo4j_impl.py, postgres_impl.py)과의 호환성 문제와 그래프 데이터의 무결성을 보장하기 위한 트랜잭션 처리 방식을 설명합니다.

## LightRAG 클래스의 저장소 초기화

`LightRAG` 클래스는 지식 그래프 생성 및 관리를 위한 핵심 구성 요소입니다. 이 클래스는 다양한 저장소 인스턴스를 초기화하고 관리하는 역할을 합니다. 초기화 과정은 `__post_init__` 메서드에서 시작되며, 이 메서드는 `LightRAG` 인스턴스가 생성될 때 자동으로 호출됩니다.

`__post_init__` 메서드는 먼저 `verify_storage_implementation` 함수를 사용하여 지정된 저장소 구현이 유효한지 확인합니다. 이는 `KV_STORAGE`, `VECTOR_STORAGE`, `GRAPH_STORAGE`, `DOC_STATUS_STORAGE`와 같은 저장소 유형에 대해 수행됩니다. 유효성 검사가 완료되면, 각 저장소 유형에 대한 클래스를 가져와 인스턴스화합니다. 예를 들어, `kv_storage` 필드에 지정된 `JsonKVStorage` 클래스는 `key_string_value_json_storage_cls`에 할당됩니다.

이후, 각 저장소 인스턴스는 `partial` 함수를 사용하여 전역 설정을 포함한 초기화 인수를 전달받습니다. 이 과정을 통해 `llm_response_cache`, `text_chunks`, `full_docs`, `full_entities`, `full_relations`, `chunk_entity_relation_graph`, `entities_vdb`, `relationships_vdb`, `chunks_vdb`, `doc_status` 등의 저장소 인스턴스가 생성됩니다. 이들 인스턴스는 각각 LLM 응답 캐시, 텍스트 청크, 전체 문서, 엔티티, 관계, 지식 그래프, 엔티티 벡터 저장소, 관계 벡터 저장소, 청크 벡터 저장소, 문서 상태 저장소를 담당합니다.

저장소 인스턴스의 생성이 완료되면, `initialize_storages` 메서드를 호출하여 각 저장소를 초기화합니다. 이 메서드는 저장소 인스턴스의 `initialize` 메서드를 순차적으로 호출하여 저장소를 준비합니다. 초기화 과정은 저장소 간의 교착 상태를 방지하기 위해 하나씩 수행됩니다.

**Section sources**
- [lightrag.py](file://lightrag/lightrag.py#L103-L149)
- [lightrag.py](file://lightrag/lightrag.py#L53-L109)

## _rebuild_knowledge_from_chunks 함수 분석

`_rebuild_knowledge_from_chunks` 함수는 캐시된 추출 결과를 사용하여 지식 그래프를 재구성하는 핵심 함수입니다. 이 함수는 `entities_to_rebuild`와 `relationships_to_rebuild`라는 두 개의 딕셔너리를 인자로 받으며, 각각 재구성할 엔티티와 관계를 포함합니다. 또한, `knowledge_graph_inst`, `entities_vdb`, `relationships_vdb`, `text_chunks_storage`, `llm_response_cache`, `global_config` 등의 저장소 인스턴스와 전역 설정도 인자로 받습니다.

함수는 먼저 `all_referenced_chunk_ids`를 생성하여 재구성에 필요한 모든 청크 ID를 수집합니다. 이후, `llm_response_cache`에서 캐시된 추출 결과를 가져옵니다. 이 과정에서 `text_chunks_storage`를 사용하여 청크 데이터와 LLM 캐시 참조를 가져옵니다. 캐시된 결과는 `chunk_entities`와 `chunk_relationships`라는 두 개의 딕셔너리에 저장되며, 각각 청크별 엔티티와 관계를 포함합니다.

재구성 과정은 비동기적으로 수행되며, `llm_model_max_async` 설정에 따라 병렬 처리됩니다. `semaphore`를 사용하여 동시에 실행되는 작업의 수를 제한합니다. `asyncio.create_task`를 사용하여 `_locked_rebuild_entity`와 `_locked_rebuild_relationship` 함수를 비동기적으로 실행합니다. 이들 함수는 각각 엔티티와 관계를 재구성하며, `get_storage_keyed_lock`을 사용하여 데이터 일관성을 보장합니다.

재구성 과정이 완료되면, `rebuilt_entities_count`와 `rebuilt_relationships_count` 변수를 사용하여 성공적으로 재구성된 엔티티와 관계의 수를 추적합니다. 오류가 발생한 경우, `failed_entities_count`와 `failed_relationships_count` 변수를 사용하여 실패한 수를 추적합니다. 최종적으로, 재구성 결과를 로그에 기록합니다.

**Section sources**
- [operate.py](file://lightrag/operate.py#L0-L799)

## 동시성 제어 메커니즘

`get_storage_keyed_lock`은 LightRAG 프레임워크에서 데이터 일관성을 보장하기 위한 동시성 제어 메커니즘입니다. 이 메커니즘은 `KeyedUnifiedLock` 클래스를 통해 구현되며, 단일 프로세스 및 다중 프로세스 환경에서 모두 작동합니다.

`KeyedUnifiedLock` 클래스는 `UnifiedLock` 클래스를 사용하여 비동기 및 멀티프로세싱 락을 통합합니다. `UnifiedLock`은 `asyncio.Lock`과 `multiprocessing.Lock`을 모두 지원하며, `__aenter__`와 `__aexit__` 메서드를 통해 비동기 컨텍스트 관리자로 사용할 수 있습니다. `KeyedUnifiedLock`은 `get_or_create_shared_raw_mp_lock` 함수를 사용하여 멀티프로세싱 락을 가져오거나 생성합니다. 이 함수는 `_lock_registry`와 `_lock_registry_count` 딕셔너리를 사용하여 락을 관리합니다.

`get_storage_keyed_lock` 함수는 `namespace`와 `keys`를 인자로 받아, 각 키에 대해 `UnifiedLock` 인스턴스를 생성합니다. 이 인스턴스는 `enable_logging` 인자를 사용하여 로깅을 활성화하거나 비활성화할 수 있습니다. `KeyedUnifiedLock`은 `cleanup_expired_locks` 메서드를 사용하여 만료된 락을 정리합니다. 이 메서드는 `CLEANUP_KEYED_LOCKS_AFTER_SECONDS` 설정에 따라 락을 정리하며, `MIN_CLEANUP_INTERVAL_SECONDS` 설정에 따라 정리 간격을 제한합니다.

**Section sources**
- [shared_storage.py](file://lightrag/kg/shared_storage.py#L0-L799)

## 다양한 그래프 저장소 구현과의 호환성

LightRAG 프레임워크는 다양한 그래프 저장소 구현과의 호환성을 제공합니다. 기본적으로 `NetworkXStorage`가 사용되지만, `Neo4JStorage`와 `PostgresStorage`도 지원됩니다. 이러한 구현들은 `BaseGraphStorage` 인터페이스를 상속받아 일관된 API를 제공합니다.

`NetworkXStorage`는 `networkx` 라이브러리를 사용하여 그래프를 메모리에 저장합니다. 이 구현은 `graphml` 파일 형식을 사용하여 그래프를 디스크에 저장하고, `initialize` 메서드를 통해 저장소를 초기화합니다. `index_done_callback` 메서드는 그래프를 디스크에 저장하고, 다른 프로세스에 데이터 업데이트를 알립니다.

`Neo4JStorage`는 `neo4j` 라이브러리를 사용하여 Neo4j 데이터베이스에 그래프를 저장합니다. 이 구현은 `AsyncGraphDatabase`를 사용하여 비동기적으로 데이터베이스에 연결하며, `initialize` 메서드를 통해 데이터베이스를 초기화합니다. `has_node`, `has_edge`, `get_node`, `get_edge` 등의 메서드는 Cypher 쿼리를 사용하여 노드와 엣지를 조회합니다.

`PostgresStorage`는 `asyncpg` 라이브러리를 사용하여 PostgreSQL 데이터베이스에 그래프를 저장합니다. 이 구현은 `Apache AGE` 확장을 사용하여 그래프 연산을 수행하며, `initialize` 메서드를 통해 데이터베이스를 초기화합니다. `configure_age_extension` 메서드는 `AGE` 확장을 생성하거나 존재하는지 확인합니다.

**Section sources**
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py#L0-L499)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L0-L799)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py#L0-L799)

## 트랜잭션 처리 및 데이터 무결성

LightRAG 프레임워크는 그래프 데이터의 무결성을 보장하기 위해 트랜잭션 처리를 사용합니다. 각 저장소 구현은 `index_done_callback` 메서드를 통해 트랜잭션을 커밋합니다. 이 메서드는 저장소의 변경 사항을 디스크에 저장하고, 다른 프로세스에 데이터 업데이트를 알립니다.

`NetworkXStorage`는 `index_done_callback` 메서드에서 `_storage_lock`을 사용하여 저장소를 잠급니다. 이 락은 다른 프로세스가 저장소를 수정하는 것을 방지합니다. 저장소가 업데이트된 경우, `NetworkXStorage.write_nx_graph` 함수를 사용하여 그래프를 디스크에 저장하고, `set_all_update_flags` 함수를 사용하여 다른 프로세