
# 동시성 제어 및 데이터 무결성

<cite>
**이 문서에서 참조된 파일**   
- [shared_storage.py](file://lightrag/kg/shared_storage.py)
- [operate.py](file://lightrag/operate.py)
- [base.py](file://lightrag/base.py)
- [lightrag.py](file://lightrag/lightrag.py)
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py)
</cite>

## 목차
1. [소개](#소개)
2. [get_storage_keyed_lock을 통한 동시성 제어](#get_storage_keyed_lock을-통한-동시성-제어)
3. [_rebuild_single_entity 및 _rebuild_single_relationship에서의 데이터 무결성 보장](#_rebuild_single_entity-및-_rebuild_single_relationship에서의-데이터-무결성-보장)
4. [다른 그래프 저장소 구현과의 호환성](#다른-그래프-저장소-구현과의-호환성)
5. [트랜잭션 처리 및 오류 복구 전략](#트랜잭션-처리-및-오류-복구-전략)
6. [결론](#결론)

## 소개
LightRAG는 대규모 지식 그래프를 효율적으로 관리하고 쿼리하는 데 중점을 둔 경량 RAG(Retrieval-Augmented Generation) 프레임워크입니다. 이 문서는 LightRAG의 핵심 메커니즘 중 하나인 동시성 제어와 데이터 무결성 보장을 설명합니다. 특히, `get_storage_keyed_lock` 함수가 다양한 저장소 백엔드에서 동일한 엔티티나 관계에 대한 동시 접근을 어떻게 방지하는지, `_rebuild_single_entity` 및 `_rebuild_single_relationship` 함수가 데이터 무결성을 어떻게 보장하는지, 그리고 다양한 그래프 저장소 구현(Neo4j, PostgreSQL, Memgraph 등)과의 호환성을 어떻게 유지하는지에 대해 자세히 설명합니다. 또한, 시스템의 안정성을 보장하기 위한 트랜잭션 처리 및 오류 복구 전략도 다룹니다.

## get_storage_keyed_lock을 통한 동시성 제어

`get_storage_keyed_lock` 함수는 LightRAG의 동시성 제어의 핵심입니다. 이 함수는 Redis 또는 파일 시스템 기반의 분산 락을 사용하여 여러 프로세스 또는 스레드가 동일한 데이터에 동시에 접근하는 것을 방지함으로써 데이터 무결성을 보장합니다.

### 함수 정의 및 작동 원리
```python
def get_storage_keyed_lock(
    keys: str | list[str], namespace: str = "default", enable_logging: bool = False
) -> _KeyedLockContext:
    """Return unified storage keyed lock for ensuring atomic operations across different namespaces"""
    global _storage_keyed_lock
    if _storage_keyed_lock is None:
        raise RuntimeError("Shared-Data is not initialized")
    if isinstance(keys, str):
        keys = [keys]
    return _storage_keyed_lock(namespace, keys, enable_logging=enable_logging)
```
이 함수는 `namespace`와 `keys`를 인자로 받아, 해당 조합에 대한 고유한 락을 생성하고 반환합니다. `namespace`는 일반적으로 `GraphDB`와 같은 저장소 유형을 나타내며, `keys`는 락을 걸고자 하는 특정 엔티티 이름이나 관계 쌍입니다. 이 함수는 내부적으로 `KeyedUnifiedLock` 클래스의 인스턴스를 사용하여 락을 관리합니다.

### 분산 락의 구현
`KeyedUnifiedLock`은 단일 프로세스 모드와 다중 프로세스(멀티프로세스) 모드 모두에서 작동하도록 설계되었습니다. 멀티프로세스 환경에서는 `multiprocessing.Manager`를 사용하여 공유 메모리에 락 레지스트리(`_lock_registry`)를 유지합니다. 각 락은 `namespace`와 `key`를 결합한 고유한 문자열(`combined_key`)을 키로 사용하여 관리됩니다. 이는 Redis와 같은 외부 분산 락 매니저를 사용하는 것과 유사한 효과를 내며, 여러 워커 프로세스가 동일한 데이터에 대한 접근을 안전하게 동기화할 수 있게 합니다.

### 락의 생명주기
락은 `async with` 문을 사용하여 획득하고 해제됩니다. `get_storage_keyed_lock`은 `_KeyedLockContext` 객체를 반환하며, 이 객체는 `__aenter__` 메서드에서 락을 획득하고 `__aexit__` 메서드에서 락을 해제하는 역할을 합니다. 락은 사용이 끝나면 즉시 해제되며, 일정 시간 동안 사용되지 않은 락은 정리 루틴에 의해 자동으로 제거되어 메모리 누수를 방지합니다.

**Section sources**
- [shared_storage.py](file://lightrag/kg/shared_storage.py#L875-L884)

## _rebuild_single_entity 및 _rebuild_single_relationship에서의 데이터 무결성 보장

`_rebuild_single_entity` 및 `_rebuild_single_relationship` 함수는 지식 그래프의 엔티티와 관계를 재구축하는 데 사용되며, `get_storage_keyed_lock`을 활용하여 데이터 무결성을 철저히 보장합니다.

### 엔티티 재구축 (_rebuild_single_entity)
이 함수는 특정 엔티티에 대한 설명을 여러 텍스트 청크에서 추출된 정보를 기반으로 재구성합니다. 중요한 점은 이 함수가 호출되기 전에 반드시 해당 엔티티 이름에 대한 락을 획득해야 한다는 것입니다. 이는 `get_storage_keyed_lock`을 통해 이루어집니다.

```python
async def _rebuild_single_entity(
    knowledge_graph_inst: BaseGraphStorage,
    entities_vdb: BaseVectorStorage,
    entity_name: str,
    chunk_ids: set[str],
    chunk_entities: dict,
    llm_response_cache: BaseKVStorage,
    global_config: dict[str, str],
) -> None:
    # ... (함수 본문)
```
`entity_name`은 락 키로 직접 사용됩니다. 예를 들어, `Google`이라는 엔티티를 재구축할 때, `get_storage_keyed_lock(["Google"], namespace="GraphDB")`를 호출하여 `Google` 엔티티에 대한 배타적 접근 권한을 획득합니다. 이를 통해 다른 프로세스가 동시에 `Google` 엔티티를 수정하는 것을 방지하고, 데이터의 일관성을 유지합니다.

### 관계 재구축 (_rebuild_single_relationship)
관계 재구축 함수는 두 엔티티 사이의 관계를 재구성합니다. 여기서 중요한 점은 관계가 방향성이 없을 수 있으므로, 락 키를 생성할 때 소스(src)와 타겟(tgt) 엔티티의 순서를 고려해야 한다는 것입니다. 이를 위해 `sorted([src, tgt])`를 사용하여 항상 동일한 순서의 키를 생성합니다.

```python
async def _rebuild_single_relationship(
    knowledge_graph_inst: BaseGraphStorage,
    relationships_vdb: BaseVectorStorage,
    src: str,
    tgt: str,
    chunk_ids: set[str],
    chunk_relationships: dict,
    llm_response_cache: BaseKVStorage,
    global_config: dict[str, str],
) -> None:
    # ... (함수 본문)
```
예를 들어, `A`와 `B` 사이의 관계를 재구축할 때, `sorted(["A", "B"])`는 항상 `["A", "B"]`라는 정렬된 리스트를 반환합니다. 따라서 `get_storage_keyed_lock(["A", "B"], namespace="GraphDB")`를 호출하면, `A-B` 관계에 대한 배타적 접근이 보장됩니다. 이는 `B-A` 관계를 재구축하려는 다른 프로세스도 동일한 락을 획득하려고 시도하게 되어 충돌을 방지합니다.

**Section sources**
- [operate.py](file://lightrag/operate.py#L861-L999)
- [operate.py](file://lightrag/operate.py#L1002-L1122)

## 다른 그래프 저장소 구현과의 호환성

LightRAG은 `NetworkXStorage` 외에도 `Neo4JStorage`, `PGGraphStorage`, `MemgraphStorage` 등 다양한 그래프 저장소 구현을 지원합니다. 이러한 다양한 구현과의 호환성을 유지하기 위해, 공통된 락 메커니즘이 추상화되어 있습니다.

### 추상화된 저장소 인터페이스
모든 그래프 저장소 구현은 `BaseGraphStorage` 추상 클래스를 상속받습니다. 이 클래스는 `upsert_node`, `upsert_edge`, `get_node`, `get_edge` 등의 핵심 메서드를 정의합니다. `get_storage_keyed_lock`은 이러한 추상화된 인터페이스 위에서 작동하므로, 구체적인 저장소 구현이 무엇이든 상관없이 동일한 방식으로 동시성 제어를 적용할 수 있습니다.

### 구현 예시
- **NetworkXStorage**: 로컬 파일 시스템에 `.graphml` 파일로 그래프를 저장합니다. `get_storage_lock`을 사용하여 파일 쓰기 작업을 동기화합니다.
- **Neo4JStorage**: 외부 Neo4j 데이터베이스에 연결합니다. `get_graph_db_lock`을 사용하여 데이터베이스 연결과 쿼리 실행을 동기화합니다.
- **PGGraphStorage**: PostgreSQL의 Apache AGE 확장 기능을 사용합니다. `get_storage_lock`을 사용하여 트랜잭션을 관리합니다.

공통점은 모든 구현이 `initialize` 및 `finalize` 메서드를 구현하여, 저장소 초기화 및 종료 시점에 적절한 리소스 관리와 동기화를 수행한다는 것입니다. `get_storage_keyed_lock`은 이러한 저장소 인스턴스의 생명주기와 독립적으로 작동하여, 데이터 조작 단계에서의 동시성만을 책임집니다.

**Section sources**
- [base.py](file://lightrag/base.py#L360-L498)
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py#L1-L799)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L1-L799)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py#L1-L799)

## 트랜잭션 처리 및 오류 복구 전략

LightRAG은 시스템의 안정성과 데이터 일관성을 보장하기 위해 철저한 트랜잭션 처리 및 오류 복구 전략을 채택하고 있습니다.

### finalize() 메서드를 통한 리소스 정리
각 저장소 구현은 `finalize()` 메서드를 구현하여, 애플리케이션 종료 시점에 리소스를 안전하게 정리합니다. 이 메서드는 데이터베이스 연결을 닫고, 변경 사항을 디스크에 영구 저장하며, 메모리를 해제하는 등의 작업을 수행합니다.

```python
async def finalize(self):
    """Finalize the storage"""
    pass
```
예를 들어, `Neo4JStorage`의 `finalize()` 메서드는 `AsyncDriver`를 닫아 모든 네트워크 연결을 정리합니다.

### finalize_storages()의 오류 복구 전략
`LightRAG` 클래스의 `finalize_storages()` 메서드는 모든 저장소 인스턴스의 `finalize()` 메서드를 호출하여 시스템을 종료합니다. 이 메서드의 핵심 전략은 **단일 실패가 전체 종료를 방해하지 않도록 하는 것**입니다.

```python
async def finalize_storages(self):
    """Asynchronously finalize the storages with improved error handling"""
    if self._storages_status == StoragesStatus.INITIALIZED:
        storages = [
            ("full_docs", self.full_docs),
            ("text_chunks", self.text_chunks),
            # ... (다른 저장소들)
        ]

        successful_finalizations = []
        failed_finalizations = []

        for storage_name, storage in storages:
            if storage:
                try:
                    await storage.finalize()
                    successful_finalizations.append(storage_name)
                except Exception as e:
                    error_msg = f"Failed to finalize {storage_name}: {e}"
                    logger.error(error_msg)
                    failed_finalizations.append(storage_name)

        # 결과 로깅
        if successful_finalizations:
            logger.info(f"Successfully finalized {len(successful_finalizations)} storages")

        if failed_finalizations:
            logger.error(f"Failed to finalize {len(failed_finalizations)} storages: {', '.join(failed_finalizations)}")
        else:
            logger.debug("All storages finalized successfully")

        self._storages_status = StoragesStatus.FINALIZED
```
이 코드는 각 저장소의 종료를 개별적으로 시도하고, 예외가 발생하더라도 다른 저장소의 종료를 계속 진행합니다. 성공한 종료와 실패한 종료는 별도의 리스트에 기록되며, 최종적으로 요약 로그를 출력합니다. 이는 하나의 저장소가 오류로 인해 응답하지 않더라도, 나머지 저장소들이 정상적으로 종료되어 데이터 손실을 최소화할 수 있도록 합니다.

**Section sources**
-