
# 그래프 저장소 최적화

<cite>
**이 문서에서 참조된 파일**   
- [values.yaml](file://k8s-deploy/databases/neo4j/values.yaml)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [memgraph_impl.py](file://lightrag/kg/memgraph_impl.py)
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py)
</cite>

## 목차
1. [소개](#소개)
2. [Neo4j 성능 최적화](#neo4j-성능-최적화)
3. [Memgraph 성능 분석](#memgraph-성능-분석)
4. [NetworkX 메모리 기반 처리](#networkx-메모리-기반-처리)
5. [PostgreSQL 기반 그래프 저장소](#postgresql-기반-그래프-저장소)
6. [성능 튜닝 가이드](#성능-튜닝-가이드)
7. [결론](#결론)

## 소개
이 문서는 Neo4j, Memgraph, NetworkX 및 PostgreSQL 기반 그래프 저장소의 성능 최적화 전략을 설명합니다. 각 그래프 데이터베이스의 특성과 최적화 방법을 분석하여 대규모 그래프 처리 환경에서의 성능 향상을 위한 가이드를 제공합니다. 특히 Neo4j의 쿠버네티스 배포 설정, 인덱스 생성, 쿼리 프로파일링 및 관계 탐색 최적화를 위한 Cypher 쿼리 패턴을 제시합니다.

## Neo4j 성능 최적화

### 쿠버네티스 배포 설정
Neo4j를 쿠버네티스에 배포할 때, `k8s-deploy/databases/neo4j/values.yaml` 파일에서 다음과 같은 리소스 설정을 조정할 수 있습니다:

- **CPU**: 최소 2코어에서 최대 64코어까지 설정 가능
- **메모리**: 최소 2GiB에서 최대 1000GiB까지 설정 가능
- **스토리지**: 최소 1GiB에서 최대 10000GiB까지 설정 가능
- **레플리카**: 단일 노드 모드에서는 1, 복제본 모드에서는 기본값 3

```yaml
# Version
version: 5.26.5

# Mode
mode: singlealone

# CPU
cpu: 2

# Memory(Gi)
memory: 4

# Storage(Gi)
storage: 20

# Replicas
replicas: 1
```

**Section sources**
- [values.yaml](file://k8s-deploy/databases/neo4j/values.yaml#L1-L46)

### 인덱스 생성
Neo4j는 노드의 `entity_id` 속성에 인덱스를 자동으로 생성합니다. 이는 노드 조회 성능을 크게 향상시킵니다.

```python
# 인덱스 생성 코드
async with self._driver.session(database=database) as session:
    try:
        workspace_label = self._get_workspace_label()
        result = await session.run(
            f"CREATE INDEX IF NOT EXISTS FOR (n:`{workspace_label}`) ON (n.entity_id)"
        )
        await result.consume()
    except Exception as e:
        logger.warning(f"[{self.workspace}] Failed to create index: {str(e)}")
```

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L180-L195)

### 쿼리 프로파일링 및 관계 탐색 최적화
Neo4j는 APOC( Awesome Procedures On Cypher) 플러그인을 사용하여 고급 그래프 탐색 기능을 제공합니다. 그러나 APOC 플러그인이 사용 불가능한 경우, 기본 Cypher 쿼리를 사용한 폴백 메커니즘이 있습니다.

```python
async def get_knowledge_graph(
    self,
    node_label: str,
    max_depth: int = 3,
    max_nodes: int = None,
) -> KnowledgeGraph:
    """
    연결된 하위 그래프를 검색합니다.
    """
    try:
        # APOC를 사용한 고급 그래프 탐색
        full_query = f"""
        MATCH (start:`{workspace_label}`)
        WHERE start.entity_id = $entity_id
        WITH start
        CALL apoc.path.subgraphAll(start, {{
            relationshipFilter: '',
            labelFilter: '{workspace_label}',
            minLevel: 0,
            maxLevel: $max_depth,
            bfs: true
        }})
        YIELD nodes, relationships
        WITH nodes, relationships, size(nodes) AS total_nodes
        UNWIND nodes AS node
        WITH collect({{node: node}}) AS node_info, relationships, total_nodes
        RETURN node_info, relationships, total_nodes
        """
    except neo4jExceptions.ClientError as e:
        # APOC 플러그인 오류 시 기본 Cypher 쿼리로 폴백
        return await self._robust_fallback(node_label, max_depth, max_nodes)
```

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L1153-L1183)

## Memgraph 성능 분석

### 실시간 처리 능력
Memgraph은 실시간 그래프 처리에 최적화되어 있으며, 트랜잭션 수준의 재시도 로직을 통해 일시적인 오류를 처리합니다.

```python
# 트랜잭션 수준 재시도 로직
max_retries = 100
initial_wait_time = 0.2
backoff_factor = 1.1
jitter_factor = 0.1

for attempt in range(max_retries):
    try:
        # 쿼리 실행
        await session.execute_write(execute_upsert)
        break
    except (TransientError, ResultFailedError) as e:
        if is_transient:
            if attempt < max_retries - 1:
                wait_time = initial_wait_time * (backoff_factor**attempt) + random.uniform(0, jitter_factor) * initial_wait_time
                await asyncio.sleep(wait_time)
            else:
                raise
```

**Section sources**
- [memgraph_impl.py](file://lightrag/kg/memgraph_impl.py#L551-L584)

### 쿼리 최적화
Memgraph은 노드의 차수(degree)를 기준으로 높은 차수의 노드를 우선적으로 검색하여, 그래프 탐색의 효율성을 높입니다.

```python
# 높은 차수의 노드 우선 검색
main_query = f"""
MATCH (n:`{workspace_label}`)
OPTIONAL MATCH (n)-[r]-()
WITH n, COALESCE(count(r), 0) AS degree
ORDER BY degree DESC
LIMIT $max_nodes
WITH collect({{node: n}}) AS filtered_nodes
UNWIND filtered_nodes AS node_info
WITH collect(node_info.node) AS kept_nodes, filtered_nodes
OPTIONAL MATCH (a)-[r]-(b)
WHERE a IN kept_nodes AND b IN kept_nodes
RETURN filtered_nodes AS node_info,
    collect(DISTINCT r) AS relationships
"""
```

**Section sources**
- [memgraph_impl.py](file://lightrag/kg/memgraph_impl.py#L906-L934)

## NetworkX 메모리 기반 처리

### 메모리 기반 처리 한계
NetworkX는 메모리 기반 그래프 처리를 제공하지만, 대규모 그래프에서는 메모리 사용량이 급격히 증가할 수 있습니다. 따라서, 메모리 사용량을 제한하기 위해 `max_graph_nodes` 설정을 사용합니다.

```python
# 최대 노드 수 제한
if max_nodes is None:
    max_nodes = self.global_config.get("max_graph_nodes", 1000)
else:
    max_nodes = min(max_nodes, self.global_config.get("max_graph_nodes", 1000))
```

**Section sources**
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py#L4125-L4154)

### 그래프 탐색 최적화
NetworkX는 BFS(너비 우선 탐색)를 사용하여 그래프를 탐색하며, 각 깊이 수준에서 노드의 차수를 기준으로 정렬하여 높은 차수의 노드를 우선적으로 처리합니다.

```python
# BFS를 사용한 그래프 탐색
while queue and len(bfs_nodes) < max_nodes:
    current_depth = queue[0][1]
    current_level_nodes = []
    while queue and queue[0][1] == current_depth:
        current_level_nodes.append(queue.pop(0))
    
    # 차수 기준 정렬
    current_level_nodes.sort(key=lambda x: x[2], reverse=True)
    
    for current_node, depth, degree in current_level_nodes:
        if current_node not in visited:
            visited.add(current_node)
            bfs_nodes.append(current_node)
            
            if depth < max_depth:
                neighbors = list(graph.neighbors(current_node))
                unvisited_neighbors = [n for n in neighbors if n not in visited]
                for neighbor in unvisited_neighbors:
                    neighbor_degree = graph.degree(neighbor)
                    queue.append((neighbor, depth + 1, neighbor_degree))
```

**Section sources**
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py#L437-L469)

## PostgreSQL 기반 그래프 저장소

### Apache AGE 확장
PostgreSQL은 Apache AGE 확장을 사용하여 그래프 데이터베이스 기능을 제공합니다. 이 확장을 사용하면 Cypher 쿼리를 PostgreSQL에서 실행할 수 있습니다.

```python
# Apache AGE 확장 생성
async with self.db.pool.acquire() as connection:
    await PostgreSQLDB.configure_age_extension(connection)
```

**Section sources**
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py#L2847-L2873)

### 인덱스 생성
PostgreSQL 기반 그래프 저장소는 노드의 `entity_id` 속성에 인덱스를 생성하여 조회 성능을 향상시킵니다.

```python
# 인덱스 생성 쿼리
queries = [
    f'CREATE INDEX CONCURRENTLY vertex_idx_node_id ON {self.graph_name}."_ag_label_vertex" (ag_catalog.agtype_access_operator(properties, \'"entity_id"\'::agtype))',
    f'CREATE INDEX CONCURRENTLY edge_sid_idx ON {self.graph_name}."_ag_label_edge" (start_id)',
    f'CREATE INDEX CONCURRENTLY edge_eid_idx ON {self.graph_name}."_ag_label_edge" (end_id)',
    f'CREATE INDEX CONCURRENTLY entity_idx_node_id ON {self.graph_name}."base" (ag_catalog.agtype_access_operator(properties, \'"entity_id"\'::agtype))',
]
```

**Section sources**
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py#L2873-L2884)

## 성능 튜닝 가이드

### Neo4j
- **CPU 및 메모리**: 대규모 그래프 처리를 위해 충분한 CPU와 메모리를 할당합니다.
- **스토리지**: SSD를 사용하여 I/O 성능을 향상시킵니다.
- **인덱스**: 자주 조회되는 속성에 인덱스를 생성합니다.
- **쿼리 최적화**: APOC 플러그인을 사용하여 복잡한 그래프 탐색을 최적화합니다.

### Memgraph
- **실시간 처리**: 트랜잭션 수준의 재시도 로직을 사용하여 일시적인 오류를 처리합니다.
- **쿼리 최적화**: 높은 차수의 노드를 우선적으로 검색하여 그래프 탐색의 효율성을 높입니다.

### NetworkX
- **메모리 사용량**: `max_graph_nodes` 설정을 사용하여 메모리 사용량을 제한합니다.
- **그래프 탐색**: BFS를 사용하여 그래프를 탐색하며, 각 깊이 수준에서 노드의 차수를 기준으로 정렬합니다.

### PostgreSQL
- **Apache AGE 확장**: Cypher 쿼리를 사용하여 그래프 데이터를 처리합니다.
- **인덱스 생성**: 노드의 `entity_id` 속성에 인덱스를 생성하여 조회 성능을 향상시킵니다.

## 결론
Neo4j, Memgraph, NetworkX 및 PostgreSQL 기반 그래프 저장소는 각각 고유한 장점과 최적화 전략을 가지고 있습니다. Neo4j는 APOC 플러그인을 통해 고급 그래프 탐색 기능을 제공하며, Memgraph은 실시간 처리에 최적화되어 있습니다. NetworkX는 메모리 기반 처리를 제공하지만, 대규모 그래프에서는 메모리 사용량을 제한해야 합니다. PostgreSQL은 Apache AGE 확