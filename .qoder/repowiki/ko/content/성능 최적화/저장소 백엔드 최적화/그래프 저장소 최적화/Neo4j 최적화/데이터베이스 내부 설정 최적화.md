# 데이터베이스 내부 설정 최적화

<cite>
**이 문서에서 참조한 파일**  
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
</cite>

## 목차
1. [데이터베이스 연결 및 성능 튜닝을 위한 환경 변수 설정](#데이터베이스-연결-및-성능-튜닝을-위한-환경-변수-설정)
2. [인덱스 자동 생성 로직](#인덱스-자동-생성-로직)
3. [대량 데이터 처리를 위한 쿼리 최적화 패턴](#대량-데이터-처리를-위한-쿼리-최적화-패턴)
4. [워크스페이스 기반 노드 인덱싱 전략과 비동기 세션 관리](#워크스페이스-기반-노드-인덱싱-전략과-비동기-세션-관리)

## 데이터베이스 연결 및 성능 튜닝을 위한 환경 변수 설정

`Neo4jStorage` 클래스는 Neo4j 데이터베이스 연결을 설정하고 성능을 튜닝하기 위해 다양한 환경 변수를 사용합니다. 이러한 설정들은 연결 풀 관리, 트랜잭션 재시도, 타임아웃 제어 등을 통해 시스템의 안정성과 성능을 보장합니다.

### 연결 풀 및 트랜잭션 재시도 관련 설정

다음 환경 변수들은 `initialize()` 메서드 내에서 설정되며, `AsyncGraphDatabase.driver()`에 전달되어 데이터베이스 드라이버의 동작을 제어합니다.

- **`NEO4J_MAX_CONNECTION_POOL_SIZE`**:  
  최대 연결 풀 크기를 정의합니다. 기본값은 100이며, 동시 요청이 많은 환경에서는 이 값을 증가시켜야 합니다. 너무 낮은 값은 연결 부족으로 인한 지연을 유발하고, 너무 높은 값은 리소스 낭비를 초래할 수 있습니다. 일반적으로 동시 요청 수의 1.5~2배를 권장합니다.

- **`NEO4J_CONNECTION_TIMEOUT`**:  
  새 연결을 설정할 때의 최대 대기 시간(초)입니다. 기본값은 30.0초이며, 네트워크 지연이 큰 환경에서는 이 값을 높이는 것이 좋습니다.

- **`NEO4J_CONNECTION_ACQUISITION_TIMEOUT`**:  
  연결 풀에서 사용 가능한 연결을 가져오기 위한 대기 시간입니다. 기본값은 30.0초이며, 고부하 환경에서 연결 부족이 발생할 경우 이 값을 조정해야 합니다.

- **`NEO4J_MAX_TRANSACTION_RETRY_TIME`**:  
  트랜잭션 재시도 시도의 총 시간 제한입니다. 기본값은 30.0초이며, 일시적인 네트워크 장애나 서비스 불가 상태에 대응하기 위해 설정됩니다. `tenacity` 라이브러리를 사용하여 지수 백오프 전략으로 최대 3회 재시도합니다.

- **`NEO4J_MAX_CONNECTION_LIFETIME`**:  
  연결의 최대 수명(초)입니다. 기본값은 300.0초이며, 오래된 연결이 자동으로 폐기되어 연결 누수를 방지합니다.

- **`NEO4J_LIVENESS_CHECK_TIMEOUT`**:  
  연결의 활성 상태를 확인하는 주기(초)입니다. 기본값은 30.0초이며, 비활성 연결을 빠르게 제거하여 리소스 효율성을 높입니다.

- **`NEO4J_KEEP_ALIVE`**:  
  TCP 연결에 대해 keep-alive를 활성화할지 여부를 결정합니다. 기본값은 `true`이며, 장시간 실행되는 애플리케이션에서 연결 안정성을 유지하는 데 중요합니다.

이러한 설정들은 `.env` 파일 또는 `config.ini` 파일을 통해 오버라이드할 수 있으며, 환경 변수가 가장 높은 우선순위를 가집니다.

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L80-L140)

## 인덱스 자동 생성 로직

`Neo4jStorage`는 워크스페이스 기반 노드에 대해 `entity_id` 필드를 기준으로 자동 인덱스를 생성합니다. 이는 노드 조회 성능을 극대화하기 위한 핵심 전략입니다.

### 인덱스 생성 프로세스

1. **인덱스 존재 여부 확인**:  
   `CALL db.indexes()`를 사용하여 현재 워크스페이스 레이블과 `entity_id` 속성에 대한 인덱스가 이미 존재하는지 확인합니다.

2. **인덱스 생성**:  
   인덱스가 존재하지 않으면 다음 쿼리를 실행하여 생성합니다:
   ```cypher
   CREATE INDEX FOR (n:`{workspace_label}`) ON (n.entity_id)
   ```
   이는 `entity_id`를 기준으로 빠른 조회를 가능하게 하며, `MATCH` 쿼리의 성능을 크게 향상시킵니다.

3. **백워드 호환성**:  
   `CALL db.indexes()`가 지원되지 않는 Neo4j 버전의 경우, `CREATE INDEX IF NOT EXISTS` 구문을 사용하여 인덱스를 생성합니다.

이러한 자동 인덱싱은 초기화 과정에서 한 번만 수행되며, 시스템 시작 시 성능을 즉시 최적화합니다.

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L208-L232)

## 대량 데이터 처리를 위한 쿼리 최적화 패턴

대량의 노드와 엣지를 처리할 때, 개별 쿼리보다는 **배치 쿼리**를 사용하여 성능을 극대화합니다. `UNWIND` 연산자를 활용한 배치 처리 패턴이 핵심입니다.

### 주요 배치 쿼리 패턴

- **`get_nodes_batch()`**:  
  여러 노드를 한 번의 쿼리로 조회합니다. `UNWIND $node_ids AS id`를 사용하여 입력된 ID 목록을 순회하며, `MATCH` 절에서 각 노드를 조회합니다.

- **`node_degrees_batch()`**:  
  여러 노드의 차수(degree)를 한 번에 조회합니다. `UNWIND`를 사용하여 모든 노드에 대해 `count { (n)--() }`을 실행합니다.

- **`get_edges_batch()`**:  
  여러 엣지 쌍에 대한 속성을 한 번에 조회합니다. 입력된 `src`, `tgt` 쌍을 `UNWIND`로 처리하고, `collect(properties(r))`을 사용하여 결과를 수집합니다.

- **`get_nodes_edges_batch()`**:  
  여러 노드의 모든 연결된 엣지를 한 번에 조회합니다. `UNWIND`를 사용하여 각 노드에 대해 `OPTIONAL MATCH`를 수행하고, 방향 정보를 기반으로 엣지 목록을 구성합니다.

이러한 배치 처리는 네트워크 왕복 지연을 줄이고, 데이터베이스 부하를 분산시켜 대규모 그래프 처리 시 성능을 크게 향상시킵니다.

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L381-L465)

## 워크스페이스 기반 노드 인덱싱 전략과 비동기 세션 관리

### 워크스페이스 기반 인덱싱 전략

`Neo4jStorage`는 각 워크스페이스를 고유한 레이블로 처리합니다. `workspace`는 생성자에서 환경 변수 `NEO4J_WORKSPACE` 또는 기본값 `base`로 설정되며, `_get_workspace_label()` 메서드를 통해 접근됩니다. 모든 노드는 이 레이블과 `entity_id` 속성을 기반으로 인덱싱되며, 서로 다른 워크스페이스 간 데이터 격리가 보장됩니다.

이 전략은 멀티테넌시 환경에서 각 사용자 또는 프로젝트의 데이터를 안전하게 분리하면서도, 각 워크스페이스 내에서 최적화된 조회 성능을 제공합니다.

### 비동기 세션 관리

모든 데이터베이스 작업은 `async with self._driver.session()`을 통해 비동기 세션으로 수행됩니다. 이는 다음과 같은 이점을 제공합니다:

- **리소스 효율성**: 세션은 사용 후 자동으로 반환되며, 연결 풀을 효율적으로 관리합니다.
- **에러 처리**: `try-finally` 블록과 `result.consume()` 호출을 통해 결과 컨슈머가 항상 완료되도록 보장합니다.
- **쓰레드 안정성**: `get_data_init_lock()`과 `get_graph_db_lock()`을 사용하여 초기화 및 종료 시 동시성 문제를 방지합니다.

또한, `upsert_node()` 및 `upsert_edge()` 메서드에는 `tenacity` 기반 재시도 메커니즘이 적용되어, 일시적인 네트워크 오류나 서비스 불가 상태에서도 안정적인 데이터 삽입이 가능합니다.

이러한 비동기 세션 관리와 재시도 정책은 고가용성 시스템에서 데이터 무결성과 서비스 안정성을 확보하는 데 핵심적인 역할을 합니다.

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L47-L82)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L137-L140)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L1371-L1405)