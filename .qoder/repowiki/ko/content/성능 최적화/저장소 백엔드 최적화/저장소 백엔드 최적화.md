
# 저장소 백엔드 최적화

<cite>
**이 문서에서 참조한 파일**  
- [lightrag.py](file://lightrag/lightrag.py)
- [docker-compose.yml](file://docker-compose.yml)
- [k8s-deploy/databases/postgresql/values.yaml](file://k8s-deploy/databases/postgresql/values.yaml)
- [k8s-deploy/databases/neo4j/values.yaml](file://k8s-deploy/databases/neo4j/values.yaml)
- [k8s-deploy/databases/qdrant/values.yaml](file://k8s-deploy/databases/qdrant/values.yaml)
- [lightrag/kg/postgres_impl.py](file://lightrag/kg/postgres_impl.py)
- [lightrag/kg/neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [lightrag/kg/milvus_impl.py](file://lightrag/kg/milvus_impl.py)
- [lightrag/kg/qdrant_impl.py](file://lightrag/kg/qdrant_impl.py)
</cite>

## 목차
1. [소개](#소개)
2. [Kubernetes 배포 환경에서의 리소스 최적화](#kubernetes-배포-환경에서의-리소스-최적화)
3. [Docker Compose 배포 환경과의 비교](#docker-compose-배포-환경과의-비교)
4. [PostgreSQL 성능 최적화 전략](#postgresql-성능-최적화-전략)
5. [저장소 구현 클래스의 성능 영향 분석](#저장소-구현-클래스의-성능-영향-분석)
6. [벡터 저장소별 성능 튜닝](#벡터-저장소별-성능-튜닝)
7. [결론](#결론)

## 소개
LightRAG는 다양한 저장소 백엔드(PostgreSQL, Neo4j, Milvus, Qdrant 등)를 지원하는 RAG(Retrieval-Augmented Generation) 시스템으로, 각 저장소의 성능을 최적화하는 것은 전체 시스템의 효율성과 응답 속도에 결정적인 영향을 미칩니다. 본 문서는 Kubernetes 및 Docker Compose 배포 환경에서 각 데이터베이스의 리소스 할당을 최적화하는 방법을 설명하고, PostgreSQL의 인덱스 구성 및 복제 설정, 그리고 lightrag/kg의 각 저장소 구현 클래스가 벡터 유사도 검색 및 그래프 탐색 성능에 미치는 영향을 분석합니다. 또한, `vector_db_storage_cls_kwargs` 설정을 통해 저장소별 성능 튜닝을 수행하는 방법을 제시합니다.

## Kubernetes 배포 환경에서의 리소스 최적화

Kubernetes 환경에서는 `k8s-deploy/databases` 디렉터리의 각 데이터베이스 `values.yaml` 파일을 통해 CPU, 메모리, 스토리지 리소스를 정의하고 최적화할 수 있습니다. 각 데이터베이스의 리소스 요구 사항에 따라 적절한 값을 설정하는 것이 중요합니다.

### PostgreSQL 리소스 최적화
PostgreSQL의 `values.yaml` 파일은 다음과 같은 리소스 설정을 제공합니다:

```yaml
cpu: 1
memory: 1
storage: 5
replicas: 2
```

- **CPU**: 1코어로 시작하여, 쿼리 부하가 높은 경우 2-4코어로 증가시킬 수 있습니다.
- **메모리**: 1Gi로 시작하여, 데이터베이스 캐시와 연결 풀을 고려하여 2-4Gi로 증가시킬 수 있습니다.
- **스토리지**: 5Gi로 시작하여, 데이터 양에 따라 20Gi 이상으로 증가시킬 수 있습니다.
- **복제(replicas)**: 2개의 복제본을 설정하여 고가용성(HA)을 보장합니다.

**Section sources**
- [k8s-deploy/databases/postgresql/values.yaml](file://k8s-deploy/databases/postgresql/values.yaml#L1-L34)

### Neo4j 리소스 최적화
Neo4j의 `values.yaml` 파일은 다음과 같은 리소스 설정을 제공합니다:

```yaml
cpu: 2
memory: 4
storage: 20
replicas: 1
```

- **CPU**: 그래프 탐색 작업은 CPU 집약적이므로, 2코어 이상을 권장합니다.
- **메모리**: 그래프 데이터는 메모리에 상주하는 경우 성능이 크게 향상되므로, 4Gi 이상을 권장합니다.
- **스토리지**: 20Gi로 시작하여, 그래프의 크기에 따라 조정합니다.
- **복제(replicas)**: 현재는 단일 노드로 설정되어 있으나, 고가용성을 위해 복제본을 추가할 수 있습니다.

**Section sources**
- [k8s-deploy/databases/neo4j/values.yaml](file://k8s-deploy/databases/neo4j/values.yaml#L1-L47)

### Qdrant 리소스 최적화
Qdrant의 `values.yaml` 파일은 다음과 같은 리소스 설정을 제공합니다:

```yaml
cpu: 1
memory: 1
storage: 20
replicas: 1
```

- **CPU**: 벡터 유사도 검색은 CPU 집약적이므로, 1코어 이상을 권장합니다.
- **메모리**: 벡터 인덱스는 메모리에 상주하는 경우 성능이 크게 향상되므로, 1Gi 이상을 권장합니다.
- **스토리지**: 20Gi로 시작하여, 벡터 데이터의 양에 따라 조정합니다.
- **복제(replicas)**: 현재는 단일 노드로 설정되어 있으나, 고가용성을 위해 복제본을 추가할 수 있습니다.

**Section sources**
- [k8s-deploy/databases/qdrant/values.yaml](file://k8s-deploy/databases/qdrant/values.yaml#L1-L32)

## Docker Compose 배포 환경과의 비교

Docker Compose 환경에서는 `docker-compose.yml` 파일에서 리소스 제한을 설정할 수 있습니다. 그러나 Kubernetes 환경에 비해 리소스 관리 기능이 제한적입니다.

### Docker Compose 리소스 설정
`docker-compose.yml` 파일은 다음과 같은 리소스 설정을 제공합니다:

```yaml
services:
  ollama:
    ...
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: all
    #           capabilities: [gpu]
  lightrag:
    ...
    environment:
      - TIKTOKEN_CACHE_DIR=/app/data/tiktoken
    restart: unless-stopped
    depends_on:
      - ollama
```

- **리소스 제한**: `deploy` 섹션을 통해 GPU와 같은 장치를 예약할 수 있으나, CPU와 메모리의 정밀한 제어는 Kubernetes에 비해 어렵습니다.
- **환경 변수**: `TIKTOKEN_CACHE_DIR`과 같은 환경 변수를 통해 캐시 디렉터리를 설정할 수 있습니다.

### Kubernetes와 Docker Compose의 비교
- **리소스 관리**: Kubernetes는 `values.yaml`을 통해 CPU, 메모리, 스토리지의 정밀한 제어가 가능하며, 복제본을 통해 고가용성을 보장합니다. Docker Compose는 이러한 기능이 제한적입니다.
- **확장성**: Kubernetes는 자동 스케일링을 지원하여 부하에 따라 리소스를 동적으로 조정할 수 있습니다. Docker Compose는 수동으로 조정해야 합니다.
- **운영 복잡성**: Kubernetes는 설정이 복잡하지만, 대규모 배포에 적합합니다. Docker Compose는 간단한 설정으로 개발 및 테스트에 적합합니다.

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L50)

## PostgreSQL 성능 최적화 전략

PostgreSQL은 LightRAG의 주요 저장소 중 하나로, 인덱스 구성 및 복제 설정을 통해 성능을 극대화할 수 있습니다.

### 인덱스 구성
PostgreSQL의 `postgres_impl.py` 파일은 다음과 같은 인덱스 구성 전략을 사용합니다:

```python
async def configure_vector_extension(connection: asyncpg.Connection) -> None:
    """Create VECTOR extension if it doesn't exist for vector similarity operations."""
    try:
        await connection.execute("CREATE EXTENSION IF NOT EXISTS vector")
        logger.info("VECTOR extension ensured for PostgreSQL")
    except Exception as e:
        logger.warning(f"Could not create VECTOR extension: {e}")
```

- **VECTOR 확장**: 벡터 유사도 검색을 위해 `vector` 확장을 사용합니다. 이 확장은 벡터 데이터 타입과 유사도 검색 함수를 제공합니다.
- **AGE 확장**: 그래프 연산을 위해 `age` 확장을 사용할 수 있습니다.

### 복제(replication) 설정
PostgreSQL의 `values.yaml` 파일은 복제본을 2개로 설정하여 고가용성을 보장합니다:

```yaml
mode: replication
replicas: 2
```

- **복제 모드**: `replication` 모드를 사용하여 마스터-슬레이브 구조를 구성합니다. 마스터 노드는 쓰기 작업을 처리하고, 슬레이브 노드는 읽기 작업을 처리하여 부하를 분산시킵니다.
- **고가용성**: 한 노드가 실패하더라도 다른 노드가 서비스를 계속 제공할 수 있습니다.

**Section sources**
- [k8s-deploy/databases/postgresql/values.yaml](file://k8s-deploy/databases/postgresql/values.yaml#L1-L34)
- [lightrag/kg/postgres_impl.py](file://lightrag/kg/postgres_impl.py#L1-L799)

## 저장소 구현 클래스의 성능 영향 분석

lightrag/kg 디렉터리의 각 저장소 구현 클래스는 벡터 유사도 검색 및 그래프 탐색 성능에 직접적인 영향을 미칩니다.

### PostgreSQL 구현 클래스
`postgres_impl.py` 파일은 PostgreSQL을 위한 벡터 저장소 클래스를 정의합니다:

```python
class PostgreSQLDB:
    def __init__(self, config: dict[str, Any], **kwargs: Any):
        self.host = config["host"]
        self.port = config["port"]
        self.user = config["user"]
        self.password = config["password"]
        self.database = config["database"]
        self.workspace = config["workspace"]
        self.max = int(config["max_connections"])
```

- **연결 풀**: `max_connections`를 통해 연결 풀의 크기를 설정하여 동시 연결 수를 제어합니다.
- **벡터 인덱스**: `vector` 확장을 사용하여 벡터 유사도 검색을 최적화합니다.

### Neo4j 구현 클래스
`neo4j_impl.py` 파일은 Neo4j를 위한 그래프 저장소 클래스를 정의합니다:

```python
@final
@dataclass
class Neo4JStorage(BaseGraphStorage):
    def __init__(self, namespace, global_config, embedding_func, workspace=None):
        super().__init__(
            namespace=namespace,
            workspace=workspace,
            global_config=global_config,
            embedding_func=embedding_func,
        )
        self._driver = None
```

- **드라이버**: `AsyncGraphDatabase.driver`를 사용하여 비동기 드라이버를 초기화합니다.
- **인덱스**: 워크스페이스 레이블에 대해 `entity_id` 인덱스를 생성하여 노드 조회 성능을 향상시킵니다.

### Milvus 구현 클래스
`milvus_impl.py` 파일은 Milvus를 위한 벡터 저장소 클래스를 정의합니다:

```python
@final
@dataclass
class MilvusVectorDBStorage(BaseVectorStorage):
    def _create_schema_for_namespace(self) -> CollectionSchema:
        dimension = self.embedding_func.embedding_dim
        base_fields = [
            FieldSchema(name="id", dtype=DataType.VARCHAR, max_length=64, is_primary=True),
            FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=dimension),
            FieldSchema(name="created_at", dtype=DataType.INT64),
        ]
```

- **스키마**: