# 확장 가이드

<cite>
**이 문서에서 참조된 파일**   
- [base.py](file://lightrag/base.py)
- [binding_options.py](file://lightrag/llm/binding_options.py)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [ollama.py](file://lightrag/llm/ollama.py)
- [kg/\_\_init\_\_.py](file://lightrag/kg/__init__.py)
- [shared_storage.py](file://lightrag/kg/shared_storage.py)
</cite>

## 목차
1. [소개](#소개)
2. [스토리지 백엔드 추가하기](#스토리지-백엔드-추가하기)
3. [LLM 공급자 추가하기](#llm-공급자-추가하기)
4. [예제 분석: Neo4j 및 Ollama 구현](#예제-분석-neo4j-및-ollama-구현)
5. [결론](#결론)

## 소개
이 문서는 LightRAG 프로젝트에 새로운 스토리지 백엔드 또는 LLM 공급자를 추가하는 확장 가이드를 제공합니다. LightRAG는 다양한 스토리지 유형(KV_STORAGE, VECTOR_STORAGE, GRAPH_STORAGE, DOC_STATUS_STORAGE)과 LLM 공급자를 유연하게 확장할 수 있도록 설계되어 있으며, 이를 위해 추상화된 인터페이스와 모듈식 구조를 제공합니다. 본 가이드에서는 `BaseKVStorage`, `BaseVectorStorage`, `BaseGraphStorage` 인터페이스를 구현하는 방법과, `lightrag/llm/binding_options.py`를 기반으로 새로운 LLM 바인딩을 등록하는 절차를 상세히 설명합니다. 또한, `neo4j_impl.py` 및 `ollama.py`의 실제 구조를 분석하여 추상 메서드 오버라이드, 오류 처리, 설정 로딩 방법을 포함한 모범 사례를 제시합니다.

## 스토리지 백엔드 추가하기

LightRAG의 스토리지 시스템은 네 가지 주요 유형으로 분류됩니다: `KV_STORAGE`(키-값 저장), `VECTOR_STORAGE`(벡터 저장), `GRAPH_STORAGE`(그래프 저장), `DOC_STATUS_STORAGE`(문서 상태 저장). 새로운 스토리지 백엔드를 추가하려면 먼저 해당 유형의 추상 기본 클래스를 상속받아 구현해야 합니다. 각 클래스는 `lightrag/base.py`에 정의된 `BaseKVStorage`, `BaseVectorStorage`, `BaseGraphStorage` 등의 인터페이스를 따릅니다. 이 인터페이스는 `@abstractmethod` 데코레이터로 표시된 추상 메서드를 포함하며, 이는 모든 하위 클래스가 반드시 구현해야 하는 핵심 기능을 정의합니다. 예를 들어, `BaseGraphStorage`는 `has_node`, `upsert_node`, `get_node` 등의 메서드를 요구합니다. 구현 시에는 `@final` 및 `@dataclass` 데코레이터를 사용하여 클래스를 최종적으로 정의하고 데이터 구조를 명확히 해야 합니다. 또한, `initialize` 메서드를 통해 데이터베이스 연결을 설정하고, `finalize` 메서드를 통해 리소스를 정리하는 것이 중요합니다. 이는 애플리케이션의 생명주기와 동기화되어 안정적인 동작을 보장합니다.

**소스 섹션**
- [base.py](file://lightrag/base.py#L211-L344)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L106-L124)

## LLM 공급자 추가하기

새로운 LLM 공급자를 추가하기 위해서는 `lightrag/llm/binding_options.py` 파일 내에 있는 `BindingOptions` 클래스를 확장해야 합니다. 이 클래스는 LLM 공급자의 구성 옵션을 표준화된 방식으로 관리하는 데 사용됩니다. 새로운 바인딩을 등록하려면 먼저 `@dataclass` 데코레이터를 사용하여 새로운 옵션 클래스를 정의하고, `_binding_name`이라는 클래스 변수를 설정하여 고유한 바인딩 이름을 지정해야 합니다. 이 이름은 명령줄 인수와 환경 변수의 접두사로 사용됩니다. 예를 들어, `OllamaLLMOptions` 클래스는 `_binding_name = "ollama_llm"`을 설정하여 `--ollama-llm-*` 형식의 인수를 생성합니다. 다음으로, 각 구성 옵션(예: `num_ctx`, `temperature`)을 데이터 클래스의 필드로 정의하고, `_help` 클래스 변수를 사용하여 각 옵션에 대한 도움말 메시지를 제공할 수 있습니다. 이 구조를 따르면, `add_args` 메서드가 자동으로 명령줄 인수를 생성하고, `options_dict` 메서드가 파싱된 인수에서 해당 바인딩의 옵션만 추출할 수 있습니다. 마지막으로, `lightrag/llm/` 디렉터리에 새로운 공급자 모듈(예: `myllm.py`)을 생성하고, 여기에 실제 API 호출 로직을 구현하면 됩니다.

**소스 섹션**
- [binding_options.py](file://lightrag/llm/binding_options.py#L1-L100)
- [binding_options.py](file://lightrag/llm/binding_options.py#L200-L250)

## 예제 분석: Neo4j 및 Ollama 구현

### Neo4jImpl.py 구조 분석
`neo4j_impl.py` 파일은 `BaseGraphStorage` 인터페이스를 구현하는 `Neo4JStorage` 클래스를 포함합니다. 이 클래스는 `__init__` 메서드에서 `workspace` 및 `global_config`와 같은 설정을 초기화합니다. `initialize` 메서드는 `AsyncGraphDatabase.driver`를 사용하여 Neo4j 서버에 비동기적으로 연결하고, 필요한 경우 데이터베이스를 생성하며, 노드 인덱스를 설정합니다. 이 과정에서 `NEO4J_URI`, `NEO4J_USERNAME`, `NEO4J_PASSWORD`와 같은 환경 변수를 우선적으로 사용하여 설정을 로드합니다. 주요 메서드들은 `async with` 문을 사용하여 Neo4j 세션을 관리하며, Cypher 쿼리를 실행합니다. 예를 들어, `has_node` 메서드는 `MATCH (n:Label {entity_id: $entity_id}) RETURN count(n) > 0` 쿼리를 사용하여 노드의 존재 여부를 확인합니다. 오류 처리는 `try-except` 블록을 통해 이루어지며, `logger.error`를 사용하여 오류를 기록하고 예외를 다시 발생시킵니다. `upsert_node` 및 `upsert_edge` 메서드는 `MERGE` 및 `SET` Cypher 명령어를 사용하여 노드와 엣지를 삽입하거나 업데이트합니다.

**소스 섹션**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L106-L150)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L200-L250)

### Ollama.py 구조 분석
`ollama.py` 파일은 Ollama LLM 공급자와의 통합을 담당합니다. 핵심 함수는 `_ollama_model_if_cache`이며, 이 함수는 `tenacity` 라이브러리를 사용하여 `RateLimitError`, `APIConnectionError`, `APITimeoutError`와 같은 특정 예외에 대해 자동으로 재시도를 수행합니다. 이 함수는 `ollama.AsyncClient`를 사용하여 비동기적으로 Ollama 서버에 연결하고, `messages` 배열에 시스템 프롬프트, 대화 기록, 사용자 프롬프트를 구성한 후 `client.chat` 메서드를 호출합니다. 스트리밍 응답을 지원하기 위해, `stream=True`일 경우 `AsyncIterator`를 반환하는 내부 제너레이터 함수를 정의합니다. 오류 처리는 `try-except-finally` 블록을 통해 이루어지며, 예외 발생 시 클라이언트 연결을 안전하게 닫습니다. `ollama_model_complete` 및 `ollama_embed` 함수는 이 핵심 함수를 래핑하여 LightRAG의 상위 레벨 API와 연결합니다. 설정 로딩은 `host`, `timeout`, `api_key`와 같은 매개변수를 `kwargs`에서 추출하여 직접 처리합니다.

**소스 섹션**
- [ollama.py](file://lightrag/llm/ollama.py#L50-L100)
- [ollama.py](file://lightrag/llm/ollama.py#L120-L170)

## 결론
이 가이드를 통해 LightRAG에 새로운 스토리지 백엔드와 LLM 공급자를 추가하는 방법을 체계적으로 이해할 수 있었습니다. 핵심은 각 유형의 추상 인터페이스를 정확히 따르고, 초기화 및 종료 라이프사이클을 올바르게 관리하며, 오류 처리와 로깅을 철저히 하는 것입니다. `neo4j_impl.py`와 `ollama.py`의 예제는 이러한 원칙을 잘 보여주며, 새로운 구현을 시작할 때 훌륭한 참고 자료가 됩니다. 확장을 통해 LightRAG의 기능을 사용자 정의 환경에 맞게 유연하게 조정할 수 있습니다.