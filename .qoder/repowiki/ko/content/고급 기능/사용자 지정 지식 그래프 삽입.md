# 사용자 지정 지식 그래프 삽입

<cite>
**이 문서에서 참조된 파일**   
- [insert_custom_kg.py](file://examples/insert_custom_kg.py)
- [lightrag.py](file://lightrag/lightrag.py)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [mongo_impl.py](file://lightrag/kg/mongo_impl.py)
- [types.py](file://lightrag/types.py)
- [shared_storage.py](file://lightrag/kg/shared_storage.py)
</cite>

## 목차
1. [소개](#소개)
2. [사용자 지정 지식 그래프 삽입 개요](#사용자-지정-지식-그래프-삽입-개요)
3. [데이터 형식 및 스키마 요구사항](#데이터-형식-및-스키마-요구사항)
4. [다양한 저장소 백엔드에 대한 삽입 예제](#다양한-저장소-백엔드에-대한-삽입-예제)
5. [성능 최적화 전략](#성능-최적화-전략)
6. [삽입 후 검색 정확도 검증](#삽입-후-검색-정확도-검증)
7. [결론](#결론)

## 소개
이 문서는 LightRAG 시스템에 사용자가 직접 생성한 지식 그래프를 삽입하는 고급 프로세스를 설명합니다. 기존 문서 파이프라인(청크화, 추출)을 우회하여 JSON 또는 데이터베이스를 통해 엔티티와 관계를 직접 주입하는 방법을 단계별로 안내합니다. 다양한 저장소 백엔드에 대한 삽입 예제, 데이터 형식 및 스키마 요구사항, 성능 최적화 전략, 그리고 삽입 후 검색 정확도 검증 방법을 포함합니다.

## 사용자 지정 지식 그래프 삽입 개요
LightRAG 시스템은 사용자가 직접 생성한 지식 그래프를 삽입할 수 있는 기능을 제공합니다. 이 기능은 기존 문서 파이프라인을 우회하여 엔티티와 관계를 직접 주입할 수 있게 해줍니다. 이를 통해 사용자는 더 유연하고 효율적인 방식으로 지식 그래프를 구성할 수 있습니다.

### 주요 이점
- **유연성**: 사용자가 직접 지식 그래프를 구성할 수 있어, 특정 요구사항에 맞게 조정할 수 있습니다.
- **효율성**: 기존 문서 파이프라인을 우회하여, 불필요한 처리 단계를 생략할 수 있습니다.
- **정확성**: 사용자가 직접 생성한 데이터를 사용하므로, 데이터의 정확성을 보장할 수 있습니다.

### 주의사항
- **데이터 일관성**: 사용자가 생성한 데이터가 일관성 있게 유지되어야 합니다.
- **성능**: 대량의 데이터를 삽입할 때는 성능 최적화 전략을 고려해야 합니다.
- **검증**: 삽입 후 검색 정확도를 검증하여, 데이터의 정확성을 확인해야 합니다.

**Section sources**
- [insert_custom_kg.py](file://examples/insert_custom_kg.py#L1-L115)

## 데이터 형식 및 스키마 요구사항
사용자 지정 지식 그래프를 삽입하기 위해서는 특정 데이터 형식과 스키마를 준수해야 합니다. 아래는 지식 그래프 데이터의 구조와 각 필드의 설명입니다.

### 데이터 구조
```json
{
  "entities": [
    {
      "entity_name": "CompanyA",
      "entity_type": "Organization",
      "description": "A major technology company",
      "source_id": "Source1"
    },
    {
      "entity_name": "ProductX",
      "entity_type": "Product",
      "description": "A popular product developed by CompanyA",
      "source_id": "Source1"
    }
  ],
  "relationships": [
    {
      "src_id": "CompanyA",
      "tgt_id": "ProductX",
      "description": "CompanyA develops ProductX",
      "keywords": "develop, produce",
      "weight": 1.0,
      "source_id": "Source1"
    }
  ],
  "chunks": [
    {
      "content": "ProductX, developed by CompanyA, has revolutionized the market with its cutting-edge features.",
      "source_id": "Source1",
      "source_chunk_index": 0
    }
  ]
}
```

### 필드 설명
- **entity_name**: 엔티티의 이름입니다.
- **entity_type**: 엔티티의 유형입니다 (예: Organization, Person, Product).
- **description**: 엔티티에 대한 설명입니다.
- **source_id**: 엔티티의 출처 ID입니다.
- **src_id**: 관계의 출처 엔티티 ID입니다.
- **tgt_id**: 관계의 대상 엔티티 ID입니다.
- **description**: 관계에 대한 설명입니다.
- **keywords**: 관계의 키워드입니다.
- **weight**: 관계의 가중치입니다.
- **content**: 청크의 내용입니다.
- **source_chunk_index**: 청크의 인덱스입니다.

**Section sources**
- [types.py](file://lightrag/types.py#L1-L30)
- [insert_custom_kg.py](file://examples/insert_custom_kg.py#L20-L115)

## 다양한 저장소 백엔드에 대한 삽입 예제
LightRAG 시스템은 다양한 저장소 백엔드를 지원합니다. 아래는 Neo4j와 MongoDB를 사용한 삽입 예제입니다.

### Neo4j에 삽입
```python
from lightrag import LightRAG
from lightrag.llm.openai import gpt_4o_mini_complete

WORKING_DIR = "./custom_kg"

if not os.path.exists(WORKING_DIR):
    os.mkdir(WORKING_DIR)

rag = LightRAG(
    working_dir=WORKING_DIR,
    llm_model_func=gpt_4o_mini_complete,
    graph_storage="Neo4JStorage"
)

custom_kg = {
    "entities": [
        {
            "entity_name": "CompanyA",
            "entity_type": "Organization",
            "description": "A major technology company",
            "source_id": "Source1"
        }
    ],
    "relationships": [
        {
            "src_id": "CompanyA",
            "tgt_id": "ProductX",
            "description": "CompanyA develops ProductX",
            "keywords": "develop, produce",
            "weight": 1.0,
            "source_id": "Source1"
        }
    ],
    "chunks": [
        {
            "content": "ProductX, developed by CompanyA, has revolutionized the market with its cutting-edge features.",
            "source_id": "Source1",
            "source_chunk_index": 0
        }
    ]
}

rag.insert_custom_kg(custom_kg)
```

### MongoDB에 삽입
```python
from lightrag import LightRAG
from lightrag.llm.openai import gpt_4o_mini_complete

WORKING_DIR = "./custom_kg"

if not os.path.exists(WORKING_DIR):
    os.mkdir(WORKING_DIR)

rag = LightRAG(
    working_dir=WORKING_DIR,
    llm_model_func=gpt_4o_mini_complete,
    graph_storage="MongoGraphStorage"
)

custom_kg = {
    "entities": [
        {
            "entity_name": "CompanyA",
            "entity_type": "Organization",
            "description": "A major technology company",
            "source_id": "Source1"
        }
    ],
    "relationships": [
        {
            "src_id": "CompanyA",
            "tgt_id": "ProductX",
            "description": "CompanyA develops ProductX",
            "keywords": "develop, produce",
            "weight": 1.0,
            "source_id": "Source1"
        }
    ],
    "chunks": [
        {
            "content": "ProductX, developed by CompanyA, has revolutionized the market with its cutting-edge features.",
            "source_id": "Source1",
            "source_chunk_index": 0
        }
    ]
}

rag.insert_custom_kg(custom_kg)
```

**Section sources**
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py#L1-L1556)
- [mongo_impl.py](file://lightrag/kg/mongo_impl.py#L1-L2079)
- [insert_custom_kg.py](file://examples/insert_custom_kg.py#L1-L115)

## 성능 최적화 전략
대량의 데이터를 삽입할 때는 성능 최적화 전략을 고려해야 합니다. 아래는 병렬 처리 및 트랜잭션 관리 전략입니다.

### 병렬 처리
```python
import asyncio

async def insert_custom_kg_parallel(rag, custom_kg_list):
    tasks = [rag.insert_custom_kg(custom_kg) for custom_kg in custom_kg_list]
    await asyncio.gather(*tasks)

# 예제 사용
custom_kg_list = [custom_kg1, custom_kg2, custom_kg3]
await insert_custom_kg_parallel(rag, custom_kg_list)
```

### 트랜잭션 관리
```python
async def insert_custom_kg_with_transaction(rag, custom_kg):
    try:
        await rag.insert_custom_kg(custom_kg)
        await rag.commit_transaction()
    except Exception as e:
        await rag.rollback_transaction()
        raise e

# 예제 사용
await insert_custom_kg_with_transaction(rag, custom_kg)
```

**Section sources**
- [lightrag.py](file://lightrag/lightrag.py#L1977-L2010)
- [shared_storage.py](file://lightrag/kg/shared_storage.py#L1-L1321)

## 삽입 후 검색 정확도 검증
지식 그래프를 삽입한 후에는 검색 정확도를 검증해야 합니다. 아래는 검색 정확도를 검증하는 방법입니다.

### 검색 정확도 검증
```python
def verify_search_accuracy(rag, queries, expected_results):
    for query, expected in zip(queries, expected_results):
        result = rag.query(query)
        if result != expected:
            print(f"검색 오류: {query} -> {result}, 기대 결과: {expected}")
        else:
            print(f"검색 성공: {query} -> {result}")

# 예제 사용
queries = ["CompanyA develops ProductX", "PersonA works at UniversityB"]
expected_results = ["ProductX", "UniversityB"]
verify_search_accuracy(rag, queries, expected_results)
```

**Section sources**
- [lightrag.py](file://lightrag/lightrag.py#L182-L182)
- [insert_custom_kg.py](file://examples/insert_custom_kg.py#L1-L115)

## 결론
이 문서는 LightRAG 시스템에 사용자가 직접 생성한 지식 그래프를 삽입하는 고급 프로세스를 설명하였습니다. JSON 또는 데이터베이스를 통해 엔티티와 관계를 직접 주입하는 방법을 단계별로 안내하고, 기존 문서 파이프라인을 우회하는 장점과 주의사항을 설명하였습니다. 다양한 저장소 백엔드에 대한 삽입 예제, 데이터 형식 및 스키마 요구사항, 성능 최적화 전략, 그리고 삽입 후 검색 정확도 검증 방법을 포함하였습니다. 이를 통해 사용자는 더 유연하고 효율적인 방식으로 지식 그래프를 구성할 수 있습니다.