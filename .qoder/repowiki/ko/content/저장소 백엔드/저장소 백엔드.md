
# 저장소 백엔드

<cite>
**이 문서에서 참조된 파일**   
- [base.py](file://lightrag/base.py)
- [shared_storage.py](file://lightrag/kg/shared_storage.py)
- [json_kv_impl.py](file://lightrag/kg/json_kv_impl.py)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py)
- [redis_impl.py](file://lightrag/kg/redis_impl.py)
- [mongo_impl.py](file://lightrag/kg/mongo_impl.py)
- [nano_vector_db_impl.py](file://lightrag/kg/nano_vector_db_impl.py)
- [milvus_impl.py](file://lightrag/kg/milvus_impl.py)
- [qdrant_impl.py](file://lightrag/kg/qdrant_impl.py)
- [faiss_impl.py](file://lightrag/kg/faiss_impl.py)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py)
</cite>

## 목차
1. [소개](#소개)
2. [저장소 유형 분류](#저장소-유형-분류)
3. [KV 저장소](#kv-저장소)
4. [벡터 저장소](#벡터-저장소)
5. [그래프 저장소](#그래프-저장소)
6. [문서 상태 저장소](#문서-상태-저장소)
7. [shared_storage.py의 역할과 데이터 동기화 메커니즘](#shared_storagepy의-역할과-데이터-동기화-메커니즘)
8. [사용자 정의 저장소 구현](#사용자-정의-저장소-구현)
9. [결론](#결론)

## 소개
LightRAG는 다양한 데이터 저장 및 검색 요구사항을 충족하기 위해 유연하고 확장 가능한 저장소 아키텍처를 제공합니다. 이 문서는 LightRAG가 지원하는 다양한 저장소 백엔드를 KV 저장소, 벡터 저장소, 그래프 저장소, 문서 상태 저장소로 분류하여 설명합니다. 각 저장소 유형의 목적과 사용 사례를 설명하고, 다양한 구현체의 특징과 선택 기준을 제시합니다. 또한, 저장소 간 데이터 동기화 메커니즘과 사용자 정의 저장소를 구현하기 위한 추상 클래스의 인터페이스를 설명합니다.

## 저장소 유형 분류
LightRAG의 저장소 백엔드는 주요 기능에 따라 네 가지로 분류됩니다.

1.  **KV 저장소 (Key-Value Storage)**: 문서 청크, LLM 캐시, 임베딩 캐시 등 구조화된 데이터를 키-값 쌍으로 저장하고 검색합니다. 주로 빠른 조회와 저장을 위해 사용됩니다.
2.  **벡터 저장소 (Vector Storage)**: 텍스트 청크, 엔티티, 관계 등의 임베딩 벡터를 저장하고, 의미 기반의 유사도 검색을 수행합니다. RAG의 핵심인 의미 검색을 담당합니다.
3.  **그래프 저장소 (Graph Storage)**: 추출된 엔티티와 관계를 그래프 구조로 저장하고 관리합니다. 노드와 엣지 간의 연결성을 기반으로 복잡한 지식 탐색을 가능하게 합니다.
4.  **문서 상태 저장소 (Document Status Storage)**: 문서 처리 파이프라인의 상태(대기, 처리 중, 성공, 실패 등)를 추적하고 관리합니다. 처리 진행 상황 모니터링과 오류 추적에 사용됩니다.

## KV 저장소
KV 저장소는 키-값 쌍으로 데이터를 저장하는 데 사용되며, 주로 문서 청크(`text_chunks`)와 LLM 캐시(`llm_cache`)를 저장하는 데 활용됩니다. `BaseKVStorage` 추상 클래스를 통해 일관된 인터페이스를 제공합니다.

### 목적과 사용 사례
*   **목적**: 빠르고 효율적인 데이터 저장 및 조회를 제공합니다. 데이터는 키(예: 문서 ID)를 통해 직접 접근할 수 있습니다.
*   **사용 사례**:
    *   원본 문서를 작은 청크로 분할한 후, 각 청크의 내용과 메타데이터를 저장합니다.
    *   LLM의 응답을 캐시하여 동일한 입력에 대한 반복적인 호출을 방지하고 성능을 향상시킵니다.

### 구현체 비교
LightRAG는 다양한 KV 저장소 구현체를 제공하며, 각각의 특징은 다음과 같습니다.

| 구현체 | 특징 | 초기화 방법 | 성능 고려사항 |
| :--- | :--- | :--- | :--- |
| **json** | 파일 기반의 간단한 저장소입니다. 설정이 필요 없으며, 개발 및 테스트에 적합합니다. | `JsonKVStorage` 클래스를 사용하며, `working_dir`에 JSON 파일을 생성합니다. | 단일 파일에 모든 데이터를 저장하므로 대규모 데이터셋에서는 성능이 저하될 수 있습니다. 멀티프로세스 환경에서의 동시성 제어가 중요합니다. |
| **postgresql** | 트랜잭션과 강력한 데이터 무결성을 제공하는 관계형 데이터베이스입니다. 대규모, 고가용성 시스템에 적합합니다. | `PostgresKVStorage` 클래스를 사용하며, `config.ini` 또는 환경 변수를 통해 연결 정보를 설정합니다. | 초기 설정이 필요하며, 네트워크 지연이 성능에 영향을 줄 수 있습니다. `VECTOR` 확장 기능을 활용할 수 있습니다. |
| **redis** | 메모리 기반의 고성능 키-값 저장소입니다. 초고속 읽기/쓰기 성능을 제공하며, 캐싱에 최적화되어 있습니다. | `RedisKVStorage` 클래스를 사용하며, `REDIS_URI` 환경 변수 또는 `config.ini`를 통해 연결 정보를 설정합니다. | 메모리에 데이터를 저장하므로 데이터 크기가 메모리 용량을 초과하지 않도록 주의해야 합니다. 영구 저장을 위해 `AOF` 또는 `RDB` 설정이 필요할 수 있습니다. |
| **mongodb** | 스키마리스 문서 데이터베이스로, 유연한 데이터 구조를 지원합니다. 대규모 비정형 데이터 저장에 적합합니다. | `MongoKVStorage` 클래스를 사용하며, `MONGO_URI` 환경 변수 또는 `config.ini`를 통해 연결 정보를 설정합니다. | 인덱스를 적절히 설계하지 않으면 쿼리 성능이 저하될 수 있습니다. `find_one` 및 `bulk_write`와 같은 메서드를 활용하여 성능을 최적화해야 합니다. |

**Section sources**
- [base.py](file://lightrag/base.py#L304-L341)
- [json_kv_impl.py](file://lightrag/kg/json_kv_impl.py)
- [postgres_impl.py](file://lightrag/kg/postgres_impl.py)
- [redis_impl.py](file://lightrag/kg/redis_impl.py)
- [mongo_impl.py](file://lightrag/kg/mongo_impl.py)

## 벡터 저장소
벡터 저장소는 텍스트의 의미를 담고 있는 임베딩 벡터를 저장하고, 주어진 쿼리와 의미적으로 유사한 벡터를 빠르게 검색하는 데 사용됩니다. `BaseVectorStorage` 추상 클래스를 통해 일관된 인터페이스를 제공합니다.

### 목적과 사용 사례
*   **목적**: 의미 기반 검색을 수행하여, 키워드 매칭이 아닌 콘텐츠의 의미를 이해하는 검색을 가능하게 합니다.
*   **사용 사례**:
    *   사용자 쿼리와 의미적으로 유사한 문서 청크를 검색하여 RAG 파이프라인에 제공합니다.
    *   추출된 엔티티와 관계의 유사도를 기반으로 클러스터링하거나 검색합니다.

### 선택 기준
다양한 벡터 저장소 구현체 중에서 선택할 때는 다음과 같은 기준을 고려해야 합니다.

| 구현체 | 선택 기준 |
| :--- | :--- |
| **nano-vectordb** | 간단한 파일 기반 저장소로, 설정이 필요 없고 가볍습니다. 소규모 프로젝트나 빠른 프로토타이핑에 적합합니다. 하지만 대규모 데이터셋에서는 성능이 제한될 수 있습니다. |
| **milvus** | 고성능, 분산 아키텍처를 갖춘 전문 벡터 데이터베이스입니다. 대규모 데이터셋과 고성능 요구사항이 있는 프로덕션 환경에 적합합니다. HNSW와 같은 고급 인덱스를 지원합니다. |
| **qdrant** | Rust로 개발된 고성능 벡터 데이터베이스로, 실시간 검색에 최적화되어 있습니다. API가 직관적이고, 클라우드 배포가 용이합니다. 대규모 실시간 애플리케이션에 적합합니다. |
| **faiss** | Meta(Facebook)에서 개발한 고성능 벡터 검색 라이브러리입니다. CPU 기반 검색에서 매우 뛰어난 성능을 제공합니다. 자체 서버를 운영하지 않고도 고성능 검색을 구현할 수 있습니다. |

**Section sources**
- [base.py](file://lightrag/base.py#L211-L300)
- [nano_vector_db_impl.py](file://lightrag/kg/nano_vector_db_impl.py)
- [milvus_impl.py](file://lightrag/kg/milvus_impl.py)
- [qdrant_impl.py](file://lightrag/kg/qdrant_impl.py)
- [faiss_impl.py](file://lightrag/kg/faiss_impl.py)

## 그래프 저장소
그래프 저장소는 추출된 엔티티(노드)와 관계(엣지)를 그래프 구조로 저장하고 관리합니다. `BaseGraphStorage` 추상 클래스를 통해 일관된 인터페이스를 제공합니다.

### 목적과 사용 사례
*   **목적**: 엔티티 간의 복잡한 연결성을 모델링하고, 이를 기반으로 깊이 있는 지식 탐색을 수행합니다.
*   **사용 사례**:
    *   "A 회사가 개발한 제품은 무엇인가?"와 같은 복잡한 질문에 대해, A 회사와 제품 간의 관계를 따라 탐색하여 답변을 도출합니다.
    *   지식 그래프를 시각화하여 데이터의 구조와 연결성을 직관적으로 이해합니다.

### 선택 기준
| 구현체 | 선택 기준 |
| :--- | :--- |
| **networkx** | Python 기반의 메모리 내 그래프 라이브러리입니다. 설정이 필요 없고, 그래프 알고리즘을 쉽게 적용할 수 있습니다. 소규모 그래프나 분석 작업에 적합합니다. |
| **neo4j** | 전문 그래프 데이터베이스로, Cypher 쿼리 언어를 사용하여 복잡한 그래프 탐색을 수행할 수 있습니다. 대규모 그래프 데이터와 복잡한 쿼리에 적합한 프로덕션 환경용 솔루션입니다. |

**Section sources**
- [base.py](file://lightrag/base.py#L345-L668)
- [networkx_impl.py](file://lightrag/kg/networkx_impl.py)
- [neo4j_impl.py](file://lightrag/kg/neo4j_impl.py)

## 문서 상태 저장소
문서 상태 저장소는 문서 처리 파이프라인의 상태를 추적하고 관리하는 전용 저장소입니다. `DocStatusStorage` 추상 클래스를 통해 일관된 인터페이스를 제공합니다.

### 목적과 사용 사례
*   **목적**: 각 문서가 파이프라인에서 어떤 단계에 있는지(예: 대기 중, 처리 중, 완료, 실패)를 실시간으로 추적합니다.
*   **사용 사례**:
    *   웹 UI에서 문서 처리 진행 상황을 모니터링합니다.
    *   처리에 실패한 문서를 식별하고 재시도하거나 문제를 진단합니다.
    *   특정 상태(예: 완료된 문서)에 있는 문서를 필터링하여 조회합니다.

**Section sources**
- [base.py](file://lightrag/base.py#L304-L341)
- [redis_impl.py](file://lightrag/kg/redis_impl.py)
- [mongo_impl.py](file://lightrag/kg/mongo_impl.py)

## shared_storage.py의 역할과 데이터 동기화 메커니즘
`shared_storage.py` 모듈은 멀티프로세스 환경에서 저장소 간의 데이터 일관성을 유지하고 동기화하는 핵심 역할을 합니다.

### 역할
*   **공유 데이터 관리**: 여러 프로세스가 공유할 수 있는 딕셔너리(`_shared_dicts`)와 플래그(`_init_flags`, `_update_flags`)를 제공합니다.
*   **동기화 잠금 관리**: 프로세스 간의 경쟁 조건을 방지하기 위한 다양한 잠금 메커니즘(`_storage_lock`, `KeyedUnifiedLock`)을 제공합니다. 이는 데이터의 동시 접근을 제어합니다.
*   **초기화 관리**: `initialize_share_data()` 함수를 통해 공유 데이터 구조를 초기화하고, `try_initialize_namespace()` 함수를 통해 각 네임스페이스의 초기화 상태를 관리합니다.

### 데이터 동기화 메커니즘
LightRAG은 다음과 같은 메커니즘을 통해 저장소 간 데이터 동기화를 보장합니다.
1.  **업데이트 플래그 (`_update_flags`)**: 하나의 프로세스가 저장소 데이터를 변경하면, 해당 네임스페이스의 `_update_flags`를 설정합니다.
2.  **주기적 콜백 (`index_done_callback`)**: 각 저장소 구현체는 `index_done_callback` 메서드를 구현하여, 변경된 데이터를 디스크에 영구 저장합니다.
3.  **플래그 확인 및 리로드**: 다른 프로세스는 `initialize()` 또는 `_get_client()` 등의 메서드에서 `_update_flags`를 확인합니다. 플래그가 설정되어 있으면, 디스크에서 최신 데이터를 다시 로드하여 메모리의 상태를 동기화합니다.
4.  **잠금 메커니즘**: 데이터를 읽거나 쓰는 동안 `get_storage_lock()`과 같은 잠금을 획득하여, 동시에 여러 프로세스가 데이터를 변경하는 것을 방지합니다.

```mermaid
flowchart TD
A[프로세스 A: 데이터 변경] --> B[upsert() 호출]
B --> C[변경 사항을 메모리에 반영]
C --> D[set_all_update_flags() 호출]
D --> E[업데이트 플래그 설정]
F[프로세스 B: 데이터 읽기] --> G[get_by_id() 호출]
G --> H[get_storage_lock() 획득]
H --> I[업데이트 플래그 확인]
I -- 플래그 설정됨 --> J[디스크에서 데이터 리로드]
I -- 플래그 설정 안 됨 --> K[메모리 데이터 반환]
J --> L[get_storage_lock() 해제]
K --> L
L --> M[결과 반환]
```

**Diagram sources**
- [shared_storage.py](file://lightrag/kg/shared_storage.py)

**Section sources**
- [shared_storage.py](file://lightrag/kg/shared_storage.py)

## 사용자 정의 저장소 구현
LightRAG은 `BaseKVStorage`, `BaseVectorStorage`, `BaseGraphStorage`와 같은 추상 클래스를 제공하여 사용자 정의 저장소를 쉽게 구현할 수 있도록 합니다.

### 추상 클래스 인터페이스
각 추상 클래스는 핵심적인 메서드를 정의하고 있으며, 사용자 정의 구현체는 이 메서드들을 반드시 구현해야 합니다.

#### BaseKVStorage 인터페이스
```python
class BaseKVStorage(StorageNameSpace, ABC):
    @abstractmethod
    async def get_by_id(self, id: str) -> dict[str, Any] | None:
        """ID로 값을 가져옵니다."""

    @abstractmethod
    async def get_by_ids(self, ids: list[str]) -> list[dict[str, Any]]:
        """ID 목록으로 값을 가져옵니다."""

    @abstractmethod
    async def filter_keys(self, keys: set[str]) -> set[str]:
        """존재하지 않는 키를 반환합니다."""

    @abstractmethod
    async def upsert(self, data: dict[str, dict[str, Any]]) -> None:
        """데이터를 삽입하거나 업데이트합니다."""

    @abstractmethod
    async def delete(self, ids: list[str]) -> None:
        """ID 목록에 해당하는 레코드를 삭제합니다."""
```

#### BaseVectorStorage 인터페이스
```python
class BaseVectorStorage(StorageNameSpace, ABC):
    @abstractmethod
    async def query(
        self, query: str, top_k: int, ids: list[str] | None = None
    ) -> list[dict[str, Any]]:
        """벡터 저장소를 쿼리하고 상위 k개의 결과를 검색합니다."""

    @abstractmethod
    async def upsert(self, data: dict[str, dict[str, Any]]) -> None:
        """벡터를 삽입하거나 업데이트합니다."""

    @abstractmethod
    async def delete(self, ids: list[str]) -> None:
        """지정된 ID의 벡터를 삭제합니다."""

    @abstractmethod
    async def get_by_id(self, id: str) -> dict[str, Any] | None:
        """ID로 벡터 데이터를 가져옵니다."""
```

#### BaseGraphStorage 인터페이스
```python
class BaseGraphStorage(StorageNameSpace, ABC):
    @abstractmethod
    async def has_node(self, node_id: str) -> bool:
        """노드가 그래